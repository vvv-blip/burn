{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 import os\
import asyncio\
import json\
import base64\
import logging\
import threading\
from solana.rpc.api import Client\
from solana.rpc.websocket_api import SolanaWsClient, logs_subscribe\
from solders.pubkey import Pubkey\
from solders.rpc.config import RpcTransactionConfig, RpcTransactionLogsConfig\
from telegram import Bot, Update\
from telegram.error import TelegramError\
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes # Import necessary components for CommandHandler\
from firebase_admin import credentials, firestore, initialize_app\
\
# --- Set up logging ---\
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\
logger = logging.getLogger(__name__) # Define a logger instance\
\
# --- Environment Variables ---\
# Telegram Bot Token (obtained from BotFather)\
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")\
# Telegram Chat ID where messages will be sent\
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID") # This is for global notifications. Individual chat IDs are not stored directly for commands.\
# Solana RPC URL (e.g., "https://api.mainnet-beta.solana.com")\
SOLANA_RPC_URL = os.getenv("SOLANA_RPC_URL", "https://api.mainnet-beta.solana.com")\
# Solana WebSocket URL (e.g., "wss://api.mainnet-beta.solana.com")\
SOLANA_WS_URL = os.getenv("SOLANA_WS_URL", "wss://api.mainnet-beta.solana.com")\
# The public key of the token mint to monitor for burns\
TOKEN_MINT_ADDRESS_STR = os.getenv("TOKEN_MINT_ADDRESS")\
# Base64 encoded Firebase service account key JSON\
FIREBASE_SERVICE_ACCOUNT_JSON_BASE64 = os.getenv("GOOGLE_APPLICATION_CREDENTIALS_JSON_BASE64")\
\
# --- Constants ---\
# The Pubkey for the SPL Token Program (constant across Solana)\
SPL_TOKEN_PROGRAM_ID = Pubkey.from_string("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")\
\
# --- Global Variables ---\
db = None  # Firestore client\
bot = None  # Telegram bot instance\
application = None # Telegram Application instance for command handlers\
TOKEN_MINT_ADDRESS = None  # Parsed Pubkey of the token mint\
TOKEN_DECIMALS = None  # Number of decimals for the token\
# Firestore document ID for storing the total burned amount.\
# This will be dynamically generated based on the token mint address.\
TOTAL_BURNED_AMOUNT_KEY = "default_total_burned_token"\
\
# Lock for synchronizing updates to the total_burned_amount in memory if multiple\
# concurrent processes were updating it, though Firestore handles persistence atomicity.\
# Primarily for ensuring data consistency if accessing from multiple async tasks locally.\
total_burned_lock = threading.Lock()\
\
# --- Firebase Functions ---\
def initialize_firebase():\
    """Initializes the Firebase Admin SDK for Firestore access."""\
    global db\
    if not FIREBASE_SERVICE_ACCOUNT_JSON_BASE64:\
        logger.error("GOOGLE_APPLICATION_CREDENTIALS_JSON_BASE64 environment variable not set. Firebase cannot be initialized.")\
        return False\
    try:\
        # Decode the base64 string to get the service account JSON\
        service_account_info = json.loads(base64.b64decode(FIREBASE_SERVICE_ACCOUNT_JSON_BASE64).decode('utf-8'))\
        cred = credentials.Certificate(service_account_info)\
        initialize_app(cred)\
        db = firestore.client()\
        logger.info("Firebase initialized successfully.")\
        return True\
    except Exception as e:\
        logger.error(f"Error initializing Firebase: \{e\}")\
        return False\
\
async def get_total_burned_amount() -> float:\
    """\
    Retrieves the total burned amount from Firestore.\
    Returns 0.0 if not found or on error.\
    """\
    if not db:\
        logger.error("Firestore not initialized. Cannot retrieve total burned amount.")\
        return 0.0\
    try:\
        doc_ref = db.collection("token_burn_stats").document(TOTAL_BURNED_AMOUNT_KEY)\
        # Run synchronous Firestore get operation in a separate thread to avoid blocking the event loop\
        doc = await asyncio.to_thread(doc_ref.get)\
        if doc.exists:\
            # Firestore stores numbers directly. If it was stored as a string, convert it.\
            # Assuming it's stored as a float now.\
            amount = doc.to_dict().get("total_burned_amount", 0.0)\
            if isinstance(amount, (int, float)):\
                return float(amount)\
            else: # Fallback for cases where it might be a string from previous storage\
                try:\
                    return float(str(amount))\
                except ValueError:\
                    logger.warning(f"Total burned amount in Firestore is not a valid number: \{amount\}. Returning 0.0.")\
                    return 0.0\
        logger.info(f"Total burned amount document '\{TOTAL_BURNED_AMOUNT_KEY\}' not found in Firestore. Initializing to 0.0.")\
        return 0.0\
    except Exception as e:\
        logger.error(f"Error getting total burned amount from Firestore: \{e\}")\
        return 0.0\
\
async def update_total_burned_amount(amount: float):\
    """\
    Updates the total burned amount in Firestore.\
    Stores the amount as a float.\
    """\
    if not db:\
        logger.error("Firestore not initialized. Cannot update total burned amount.")\
        return\
    try:\
        doc_ref = db.collection("token_burn_stats").document(TOTAL_BURNED_AMOUNT_KEY)\
        # Store as a number directly in Firestore\
        await asyncio.to_thread(doc_ref.set, \{"total_burned_amount": amount\})\
        logger.info(f"Total burned amount in Firestore updated to \{amount\}")\
    except Exception as e:\
        logger.error(f"Error updating total burned amount in Firestore: \{e\}")\
\
# --- Solana Functions ---\
async def get_token_decimals(solana_client: Client, mint_address: Pubkey) -> int | None:\
    """\
    Fetches the number of decimals for a given token mint address.\
    """\
    try:\
        # Fetch account information for the token mint.\
        # Using jsonParsed encoding to get structured data back.\
        response = await asyncio.to_thread(solana_client.get_account_info, mint_address, encoding="jsonParsed")\
        if response and response.value:\
            # The parsed data contains the mint's info, including decimals.\
            mint_data = response.value.data.parsed["info"]\
            if mint_data["type"] == "mint":\
                decimals = mint_data["decimals"]\
                logger.info(f"Token decimals for \{mint_address\} found: \{decimals\}")\
                return decimals\
        logger.warning(f"Could not find decimals for mint address: \{mint_address\}. Account info response: \{response\}")\
        return None\
    except Exception as e:\
        logger.error(f"Error fetching token decimals for \{mint_address\}: \{e\}")\
        return None\
\
async def process_solana_transaction(solana_client: Client, signature: str):\
    """\
    Fetches a Solana transaction by signature, parses it, and processes any detected burn events.\
    """\
    global TOKEN_DECIMALS, TOKEN_MINT_ADDRESS_STR\
\
    if TOKEN_DECIMALS is None or TOKEN_MINT_ADDRESS_STR is None:\
        logger.warning("Token decimals or mint address not initialized. Skipping transaction processing.")\
        return\
\
    try:\
        # Configuration for fetching the transaction, requesting jsonParsed encoding\
        # to easily access structured instruction data.\
        config = RpcTransactionConfig(\
            encoding="jsonParsed",\
            max_supported_transaction_version=0, # Use 0 for legacy transactions, adjust if monitoring v1+\
            rewards=False,\
            commitment="confirmed" # "confirmed" ensures the transaction is on a confirmed block\
        )\
        transaction_response = await asyncio.to_thread(solana_client.get_transaction, signature, config)\
\
        if not transaction_response or not transaction_response.value:\
            logger.warning(f"Could not fetch transaction details for signature: \{signature\}")\
            return\
\
        tx = transaction_response.value\
        burned_amount_raw = 0\
        is_burn_event = False\
\
        # Iterate through the main instructions in the transaction\
        # `jsonParsed` transactions will have instructions with a `parsed` attribute\
        # for known programs like SPL Token.\
        for instruction in tx.transaction.message.instructions:\
            # Check if it's an SPL Token program instruction and if it's a burn type\
            if hasattr(instruction, 'parsed') and instruction.program_id == SPL_TOKEN_PROGRAM_ID:\
                parsed_info = instruction.parsed.get('info', \{\})\
                if instruction.parsed.get('type') in ['burn', 'burnChecked'] and \\\
                   parsed_info.get('mint') == TOKEN_MINT_ADDRESS_STR:\
                    burned_amount_raw = int(parsed_info.get('amount', 0))\
                    is_burn_event = True\
                    break # Found the relevant burn instruction, no need to check further\
\
        # Also check inner instructions (instructions called by other instructions)\
        if not is_burn_event and tx.meta and tx.meta.inner_instructions:\
            for inner_instruction_list in tx.meta.inner_instructions:\
                for instruction in inner_instruction_list.instructions:\
                    if hasattr(instruction, 'parsed') and instruction.program_id == SPL_TOKEN_PROGRAM_ID:\
                        parsed_info = instruction.parsed.get('info', \{\})\
                        if instruction.parsed.get('type') in ['burn', 'burnChecked'] and \\\
                           parsed_info.get('mint') == TOKEN_MINT_ADDRESS_STR:\
                            burned_amount_raw = int(parsed_info.get('amount', 0))\
                            is_burn_event = True\
                            break\
                if is_burn_event:\
                    break\
\
        if is_burn_event and burned_amount_raw > 0:\
            # Convert the raw amount (in lamports) to human-readable format using token decimals\
            burned_amount_readable = burned_amount_raw / (10**TOKEN_DECIMALS)\
            logger.info(f"Detected burn of \{burned_amount_readable\} tokens (raw: \{burned_amount_raw\}). Signature: \{signature\}")\
\
            # Update the total burned amount in Firestore\
            # Use the lock to ensure consistency if multiple asynchronous updates were happening simultaneously,\
            # though get/set Firestore operations are atomic for the document update itself.\
            with total_burned_lock:\
                current_total_burned = await get_total_burned_amount()\
                new_total_burned = current_total_burned + burned_amount_readable\
                await update_total_burned_amount(new_total_burned)\
\
            # Prepare and send the Telegram message\
            # For simplicity, using "JEWS" as requested previously.\
            token_symbol = "JEWS" \
            message = (\
                f"\uc0\u55357 \u56613  Someone burned \{burned_amount_readable:,.\{TOKEN_DECIMALS\}f\} $\{token_symbol\}!\\n"\
                f"\uc0\u55357 \u56522  Total amount of burned \{token_symbol\} is now \{new_total_burned:,.\{TOKEN_DECIMALS\}f\}"\
            )\
            await send_telegram_message(message)\
        else:\
            logger.debug(f"Transaction \{signature\} does not contain a relevant burn for \{TOKEN_MINT_ADDRESS_STR\}.")\
\
    except Exception as e:\
        logger.error(f"Error processing transaction \{signature\}: \{e\}")\
\
async def monitor_burns():\
    """\
    Monitors the Solana blockchain for burn events using WebSocket subscription to logs.\
    """\
    global TOKEN_DECIMALS, TOKEN_MINT_ADDRESS, TOTAL_BURNED_AMOUNT_KEY\
\
    # Validate and parse the token mint address\
    if TOKEN_MINT_ADDRESS_STR:\
        try:\
            TOKEN_MINT_ADDRESS = Pubkey.from_string(TOKEN_MINT_ADDRESS_STR)\
            # Use the token mint address to create a specific key for Firestore\
            TOTAL_BURNED_AMOUNT_KEY = f"total_burned_\{TOKEN_MINT_ADDRESS_STR.lower()\}"\
        except Exception as e:\
            logger.error(f"Invalid TOKEN_MINT_ADDRESS: \{TOKEN_MINT_ADDRESS_STR\}. Error: \{e\}")\
            return\
    else:\
        logger.error("TOKEN_MINT_ADDRESS environment variable not set. Exiting monitoring.")\
        return\
\
    # Initialize Solana RPC client\
    solana_client = Client(SOLANA_RPC_URL)\
\
    # Fetch token decimals once at startup\
    TOKEN_DECIMALS = await get_token_decimals(solana_client, TOKEN_MINT_ADDRESS)\
    if TOKEN_DECIMALS is None:\
        logger.error(f"Failed to retrieve decimals for token mint \{TOKEN_MINT_ADDRESS_STR\}. Cannot monitor burns without decimals. Exiting.")\
        return\
\
    logger.info(f"Starting to monitor burn events for token: \{TOKEN_MINT_ADDRESS_STR\} (Decimals: \{TOKEN_DECIMALS\})")\
    logger.info(f"Using Solana RPC: \{SOLANA_RPC_URL\} and WebSocket: \{SOLANA_WS_URL\}")\
\
    # Main loop for WebSocket connection and re-connection\
    while True:\
        try:\
            async with SolanaWsClient(SOLANA_WS_URL) as ws:\
                # Subscribe to logs for the SPL Token Program ID.\
                # This allows us to receive notifications whenever a transaction\
                # involves the SPL Token Program, including burn instructions.\
                await ws.logs_subscribe(\
                    filter_=RpcTransactionLogsConfig(\
                        mentions=[SPL_TOKEN_PROGRAM_ID], # Filter logs mentioning the SPL Token Program\
                        commitment="confirmed" # Listen for logs on confirmed blocks\
                    )\
                )\
\
                logger.info("Subscribed to SPL Token Program logs via WebSocket.")\
\
                # Process incoming WebSocket messages\
                async for msg in ws:\
                    try:\
                        # Extract log information from the WebSocket message\
                        # The structure is: msg -> 'params' -> 'result' -> 'value'\
                        if msg and 'params' in msg and 'result' in msg['params'] and 'value' in msg['params']['result']:\
                            log_info = msg['params']['result']['value']\
                            signature = log_info['signature']\
                            logs = log_info['logs']\
                            err = log_info['err']\
\
                            # Skip transactions that failed\
                            if err:\
                                logger.warning(f"Transaction \{signature\} failed with error: \{err\}. Skipping.")\
                                continue\
\
                            # Check if any log message indicates a "Burn" or "BurnChecked" instruction.\
                            # This is a preliminary filter to reduce unnecessary RPC calls to get full transaction details.\
                            is_burn_log = False\
                            for log in logs:\
                                if "Program log: Instruction: Burn" in log or "Program log: Instruction: BurnChecked" in log:\
                                    is_burn_log = True\
                                    break\
                            \
                            if is_burn_log:\
                                # If a potential burn log is detected, fetch and process the full transaction.\
                                logger.info(f"Detected potential burn log in transaction \{signature\}. Fetching full transaction details.")\
                                await process_solana_transaction(solana_client, signature)\
                            else:\
                                logger.debug(f"Skipping non-burn related logs for signature: \{signature\}")\
\
                    except Exception as e:\
                        logger.error(f"Error processing individual WebSocket message: \{e\}")\
        except Exception as e:\
            logger.error(f"WebSocket connection error: \{e\}. Reconnecting in 5 seconds...")\
            await asyncio.sleep(5) # Wait before attempting to reconnect\
\
# --- Telegram Functions ---\
async def send_telegram_message(message: str):\
    """\
    Sends a message to the configured Telegram chat.\
    """\
    global bot\
    if not bot:\
        logger.error("Telegram Bot not initialized. Cannot send message.")\
        return\
    if not TELEGRAM_CHAT_ID:\
        logger.error("TELEGRAM_CHAT_ID environment variable not set. Cannot send message.")\
        return\
\
    try:\
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=message)\
        logger.info(f"Telegram message sent: '\{message\}'")\
    except TelegramError as e:\
        logger.error(f"Error sending Telegram message: \{e\}")\
    except Exception as e:\
        logger.error(f"An unexpected error occurred while sending Telegram message: \{e\}")\
\
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\
    """Handles the /start command."""\
    await update.message.reply_text(\
        "\uc0\u55357 \u56613  Welcome to the Solana Burn Monitor Bot! \u55357 \u56613 \\n\\n"\
        "I will continuously monitor for token burns from the specified Solana contract address and notify this group.\\n\\n"\
        "Here are some commands:\\n"\
        "\'95 `/totalburn`: See the current total amount of $JEWS burned.\\n"\
        "\'95 `/help`: Show a list of all commands.\\n"\
        "\'95 `/whomadethebot`: Find out who crafted this bot.\\n\\n"\
        "Let the flames begin! \uc0\u55357 \u56960 ",\
        parse_mode='Markdown'\
    )\
\
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\
    """Sends a message with the list of commands."""\
    help_text = (\
        "\uc0\u55357 \u56613  Here are the commands you can use with Solana Burn Monitor Bot:\\n\\n"\
        "\'95 `/start`: See the welcome message.\\n"\
        "\'95 `/totalburn`: See the current total amount of $JEWS burned.\\n"\
        "\'95 `/whomadethebot`: Find out who crafted this bot.\\n"\
    )\
    await update.message.reply_text(help_text, parse_mode='Markdown')\
\
async def whomadethebot_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\
    """Handles the /whomadethebot command."""\
    await update.message.reply_text("@nakatroll")\
\
async def total_burn_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\
    """Handles the /totalburn command, showing the total amount of tokens burned."""\
    total_burned = await get_total_burned_amount()\
    \
    # Use "JEWS" as the token symbol as requested previously\
    token_symbol = "JEWS" \
\
    message = (\
        f"\uc0\u55357 \u56613  *Burn Status!* \u55357 \u56613 \\n\\n"\
        f"The total amount of burned $\{token_symbol\} is now: *\{total_burned:,.\{TOKEN_DECIMALS if TOKEN_DECIMALS is not None else 0\}f\}* \uc0\u55357 \u56613 \\n"\
        f"Keep those flames roaring! \uc0\u55357 \u56892 "\
    )\
    await update.message.reply_text(message, parse_mode='Markdown')\
\
\
async def run_bot():\
    """\
    Initializes and runs the Telegram bot.\
    """\
    global bot, application\
\
    # Check for essential environment variables\
    if not all([TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, TOKEN_MINT_ADDRESS_STR, FIREBASE_SERVICE_ACCOUNT_JSON_BASE64]):\
        logger.error("Missing one or more required environment variables (TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, TOKEN_MINT_ADDRESS, GOOGLE_APPLICATION_CREDENTIALS_JSON_BASE64). Please check your .env file or Render environment settings. Exiting.")\
        return\
\
    # Initialize Firebase Admin SDK\
    if not initialize_firebase():\
        logger.error("Firebase initialization failed. Cannot proceed. Exiting.")\
        return\
\
    # Initialize Telegram Bot\
    bot = Bot(token=TELEGRAM_BOT_TOKEN)\
    try:\
        bot_info = await bot.get_me()\
        logger.info(f"Telegram bot initialized successfully as @\{bot_info.username\}")\
    except TelegramError as e:\
        logger.error(f"Failed to initialize Telegram bot. Check TELEGRAM_BOT_TOKEN validity: \{e\}")\
        return\
    except Exception as e:\
        logger.error(f"Unexpected error during Telegram bot initialization: \{e\}")\
        return\
\
    # Build the Application instance for command handling\
    application = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()\
\
    # Add command handlers\
    application.add_handler(CommandHandler("start", start_command))\
    application.add_handler(CommandHandler("help", help_command))\
    application.add_handler(CommandHandler("whomadethebot", whomadethebot_command))\
    application.add_handler(CommandHandler("totalburn", total_burn_command)) # New totalburn command\
\
    # Start polling for Telegram updates in a background task\
    # This keeps the Telegram bot active and listening for commands\
    asyncio.create_task(application.run_polling())\
    logger.info("Telegram bot polling started.")\
\
    # Start the continuous burn monitoring process\
    await monitor_burns()\
\
\
if __name__ == "__main__":\
    # Run the main asynchronous function\
    try:\
        # Start both the Telegram bot polling and the Solana monitoring loop concurrently\
        asyncio.run(run_bot())\
    except KeyboardInterrupt:\
        logger.info("Bot stopped manually by KeyboardInterrupt.")\
    except Exception as e:\
        logger.critical(f"An unhandled critical error occurred, bot is stopping: \{e\}", exc_info=True)\
\
\
}